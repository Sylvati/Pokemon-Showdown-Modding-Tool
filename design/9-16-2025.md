System will work like so, standardized across different game engines:

0. Mod creation
    - Mods will be created independently of any specific game engine so they can be plug and play between each.
    - These will primarily be data-driven w/ json files, etc 
    - Mod structure, for now, will be as follows: (This should have a UI to easily create)
        - mod_name
            - dex
                - `dex.json`
            - sprites
                - all sprites as .png files
                - sprite must match name for 
    - These will be placed in the user files for the game

1. Mod loading
    - Mods will be loaded into a singleton Mod Manager in the game engine.
    - This singleton will have a dict with DexEntry templates (or game engine equivalent)
    - Once all mods are loaded, they will be compiled into a single place for usage in the game
    - Planting this food for thought, what about an initial config mod that most games should have?

2. Game beginning
    - With all mods loaded, the title screen will load
    - The title screen can be designed in the given game engine.
        - Devs can customize in the game engine of their choice, but by default will be set by mods and follow standard Pokemon design
        - Modifiable w/ mods? ex: background, title, etc
    - Once the the user presses start:
        - Devs can choose whether a beginning sequence plays or not.
        - Will default to a standard player data collection screen standard to Pokemon
            - Modifiable w/ mods.
    - Once the user is done with the data collection sequence:
        - Devs MUST decide in-game-engine what `starting_area` to use from what mod.
        - OR, Devs are free to modify code and do whatever they want. I don't really care. Shouldn't negatively impact stuff elsewhere
    - Once the player is placed into a `starting_area`
        - Allow them to play the game!
        - Maps, at this point, will be defined via .json files
            - Need a UI to design them 
            - Ideally devs could also just... use the game-engine. (This is where it gets complicated to support 3 diff engines lol)
    
3. Complex systems
    - Battle system:
        - Hook-driven to allow current moves to work and to allow more customization
        - Move order will be dynamic or static, togglable.
        - Current design idea (This will have to be psuedo-coded for easy implementation in other engines):
            - Initial-entry hook (First time a poke is sent out)
            - On-entry hook (Switch-ins)
            - Pre-move hook (Things that occur before a poke does a move)
            - During-move hook (Things that happen during a move) (Think how sleep procs, but you still move if you wake up.)
            - Post-move hook (Things that happen after a move)
    - Move system:
        - Moves will be designed with these hooks in mind.
        - Custom moves will still need to be in a mod, but it will have a data point telling it where the custom script to run is. (I'm very iffy on this. Opens up security vulnerabilites)
    - Ability system:
        - Abilities will be designed with these hooks in mind.
        - Custom abilities will work the same as custom moves.
    - Overworld system:
        - json driven map design. Or plaintext? Idk, it'll be editable with a UI
    - Encounter system:
        - data driven. Supply weights and names in mods, with route info
    - Dexnav system:
        - Just get data from the mods to construct a dexnav and the game will handle displaying the right one.
    - Dex system:
        - Just get data from mods and the game will handle displaying it properly.
    - Type charting:
        - Mods will be able to add types, so unhandled cases will default to neutral.